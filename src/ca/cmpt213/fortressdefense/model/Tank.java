package ca.cmpt213.fortressdefense.model;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Random;

//tank 生成的时候就要有四个点
//带seed random time
//也是index 1 based

/**
 * Class to represent the tanks in the game, the generation of tank location is part of this class.
 * @author Bei Bei Li + Adam Labecki
 */
public class Tank {

    private List<Coordinate> myCells = new ArrayList<>();
    private int myDamage;
    private int myID;
    private boolean alive = true;


    public Tank(int myID, int boardSizeX, int boardSizeY) {

        this.myID = myID;
        this.myDamage = 20;

        generateMyCells(boardSizeX, boardSizeY);

    }


    /**
     * Method to generate the cell location on the game board for the tank.
     * @param boardSizeX The width of the board (int)
     * @param boardSizeY The length of the board (int)
     */
    //can be refactored to another class, but I am lazy again...XD
    //uses random to select an int [-1,0,1] to form tetromino shape by growing from the previous generated point
    //T shape is generated by always using the start point as the previous generated point
    private void generateMyCells(int boardSizeX, int boardSizeY) {

        int minX = 1;
        int minY = 1;
        int maxX = boardSizeX;
        int maxY = boardSizeY;
        int nonStartCells = 3;
        int cordX = 0;
        int cordY = 0;

        //-1,0,1
        int offset = 0;
        int offsetLimit = 3;
        int offsetFix = -1;

        Date seedDate = new Date();
        long seed = seedDate.getTime();

        Random randomGenerator = new Random(seed);

        //add start
        Coordinate startPoint = createStart(boardSizeX, boardSizeY, randomGenerator);
        this.myCells.add(startPoint);

        //generate rest
        int startX = startPoint.getX();
        int startY = startPoint.getY();

        //0,1,2 减一
        for (int i = 0; i < nonStartCells; i++) {

            while (duplicatedCell(cordX, cordY) || cordX < minX || cordX > maxX || cordY < minY || cordY > maxY) {

                //picks 往左右还是往上下
                int pickXY = randomGenerator.nextInt(3);

                //move left right
                if (pickXY == 0) {
                    while (cordX < minX || cordX > maxX || cordX == startX) {
                        offset = selectOffset(startX, randomGenerator);
                        cordX = startX + offset;
                        cordY = startY;
                        //System.out.println("test");
                    }
                }
                //move up down
                else if (pickXY == 1){
                    while (cordY < minY || cordY > maxY || cordY == startY) {
                        offset = selectOffset(startY, randomGenerator);
                        cordY = startY + offset;
                        cordX = startX;
                    }
                }
                //Case to create T shape possibility
                else {

                    startX = startPoint.getX();
                    startY = startPoint.getY();

                    int XY = randomGenerator.nextInt(2);

                    //left right
                    if (pickXY == 0) {
                        while (cordX < minX || cordX > maxX || cordX == startX) {
                            offset = selectOffset(startX, randomGenerator);
                            cordX = startX + offset;
                            cordY = startY;
                        }
                    }
                    //up down
                    else if (pickXY == 1){
                        while (cordY < minY || cordY > maxY || cordY == startY) {
                            offset = selectOffset(startY, randomGenerator);
                            cordY = startY + offset;
                            cordX = startX;
                        }
                    }

                }
            }

            Coordinate nonStartCell = new Coordinate(cordX, cordY);
            this.myCells.add(nonStartCell);

            //reset key points
            startX = nonStartCell.getX();
            startY = nonStartCell.getY();
            cordX = 0;
            cordY = 0;


        }


    }

    private int selectOffset(int startCord, Random randomGenerator) {
        int result = 0;

        int offsetLimit = 3;
        int offsetFix = -1;

        if (startCord == 10){
            result = -1;
        }
        else if (startCord == 1){
            result = 1;
        }
        else {
            result = randomGenerator.nextInt(offsetLimit) + offsetFix;
        }

        return result;
    }

    /**
     * Method to check if the tank already has the cell
     * @param cordX The X cord of the cell to be checked (int)
     * @param cordY The Y cord of the cell to be checked (int)
     * @return
     */
    // algorithm to generate tank cells abandons the generated cell if tank already has it
    private boolean duplicatedCell(int cordX, int cordY){
        boolean result = false;

        for (Coordinate eachCord : this.myCells) {
            if (cordX == eachCord.getX() && cordY == eachCord.getY()) {
                result = true;
            }
        }

        return result;
    }


    /**
     * Method to randomly pick a start point on the game board to "grow the tank"
     * @param boardSizeX The width of the board (int)
     * @param boardSizeY The length of the board (int)
     * @param randomGenerator The random generator to randomly pick X,Y cords for the start point
     * @return The generated start point (Coordinate)
     */
    private Coordinate createStart(int boardSizeX, int boardSizeY, Random randomGenerator) {

        int minX = 1;
        int minY = 1;
        int maxX = boardSizeX - 1;
        int maxY = boardSizeY - 1;
        int cordX = 0;
        int cordY = 0;
        int randomOffsetFix = 1;


        while (cordX < minX || cordX > maxX) {
            cordX = randomGenerator.nextInt(maxX) + randomOffsetFix;
        }

        while (cordY < minY || cordY > maxY) {
            cordY = randomGenerator.nextInt(maxY) + randomOffsetFix;
            if (cordX == 1 && cordY == 1) {
                cordY = cordY + 1; //brute force fix, 1-1,10-10,10-1,1-10情况不能出现不然Infinite
            }
        }

        Coordinate startPoint = new Coordinate(cordX, cordY);

        return startPoint;
    }

    /**
     * Update the tank cell and mark it as hit when user hit
     * @param hit The coordinate where user hit
     */
    public void updateTankHit(Coordinate hit) {

        for (Coordinate eachCord : myCells) {
            if (eachCord.getX() == hit.getX() && eachCord.getY() == hit.getY()) {
                eachCord.setFired();
            }
        }

        updateTankDamage();


    }


    /**
     * Update the tank damage according to the number of the cells it has
     */
    private void updateTankDamage() {

        int livingCell = 0;

        for (Coordinate eachCord : myCells) {
            if (!eachCord.getHasFiredAt()) {
                livingCell++;
            }
        }

        if (livingCell == 0) {
            this.alive = false;
        }

        switch(livingCell) {
            case 0:
                myDamage = 0;
                break;
            case 1:
                myDamage = 1;
                break;
            case 2:
                myDamage = 2;
                break;
            case 3:
                myDamage = 5;
                break;
            case 4:
                myDamage = 20;
                break;
            default: //code style: All switch statements should include a "default" label. assert false if impossible.
                assert false;
        }

    }

    public int getMyDamage() {
        return this.myDamage;
    }

    public List<Coordinate> getMyCells() {
        return this.myCells;
    }

    public int getMyID() {
        return this.myID;
    }

    public boolean isAlive() {
        return this.alive;
    }
}
